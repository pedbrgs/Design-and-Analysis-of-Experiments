algo2 <- fobjs[(ninstances+1):(2*ninstances)]
# Renomeando as colunas
colnames(algo1) <- as.character(2:150)
colnames(algo2) <- as.character(2:150)
# Média de desempenho do algoritmo 1
muAlgo1 <- as.vector(colMeans(algo1))
# Média de desempenho do algoritmo 2
muAlgo2 <- as.vector(colMeans(algo2))
# Estruturando dados do algoritmo 1 para gráfico de linhas no ggplot2
label <- rep('1', ninstances)
variable <- 2:150
arr1 <- melt(muAlgo1, id.vars = NULL)
head <- cbind(variable, arr1, label)
# Estruturando dados do algoritmo 2 para gráfico de linhas no ggplot2
label <- rep('2', ninstances)
arr2 <- melt(muAlgo2, id.vars = NULL)
tail <- cbind(variable, arr2, label)
# União dos desempenhos dos dois algoritmos em todas as instâncias
merged <- rbind(head, tail)
# Lineplot
p <- ggplot(merged, aes(x = variable, y = value, color = label)) + geom_line()
p + labs(x = "Dimensão", y = "Fitness médio") +
guides(color=guide_legend(title="Algoritmo")) +
scale_color_manual(values = c("steelblue", "darkred"))
# Estruturando dados do algoritmo 1 para boxplots no ggplot2
label <- rep('1', (33 * ninstances))
arr1 <- melt(algo1, id.vars = NULL)
head <- cbind(arr1, label)
# Estruturando dados do algoritmo 2 para boxplots no ggplot2
label <- rep('2', (33 * ninstances))
arr2 <- melt(algo2, id.vars = NULL)
tail <- cbind(arr2, label)
# União dos desempenhos dos dois algoritmos nas dez primeiras instâncias
merged <- rbind(head(head, 33*10), head(tail, 33*10))
# Boxplot
p <- ggplot(data = merged, aes(x=variable, y=value)) + geom_boxplot(aes(fill=label))
p + labs(x = "Dimensão", y = "Fitness") +
scale_fill_manual(name = "Algoritmo", values = c("#56B4E9", "#CD5C5C"))
# União dos desempenhos dos dois algoritmos nas dez últimas instâncias
merged <- rbind(tail(head, 33*10), tail(tail, 33*10))
# Boxplot
p <- ggplot(data = merged, aes(x=variable, y=value)) + geom_boxplot(aes(fill=label))
p + labs(x = "Dimensão", y = "Fitness") +
scale_fill_manual(name = "Algoritmo", values = c("#56B4E9", "#CD5C5C"))
# Calcula relação entre potência e tamanho amostral
interval <- 2:150
power_values <- c()
for (i in interval) {
out <- calc_instances(ncomparisons = 1,
d = 0.5,
ninstances = i,
sig.level = 0.05,
alternative.side = "one.sided",
power.target = "mean")
power_values[i-1] <- out$power
}
df <- data.frame(x = interval, y = power_values)
ggplot(data = df, aes(x = x, y = y, group = 1)) +
xlab('Número de instâncias') +
ylab('Potência do teste') +
geom_line(linetype = 'dashed')+
geom_point()
out <- calc_instances(ncomparisons = 1,
d = 0.5,
ninstances = 149,
sig.level = 0.05,
alternative.side = "one.sided",
power.target = "mean")
cat('Potência alcançada:', out$power)
# Agregando desempenho médio dos algoritmos em todas as instâncias
aggdata <- data.frame(rbind(muAlgo1, muAlgo2))
# Renomeando colunas
colnames(aggdata) <- as.character(2:150)
# Renomeando linhas
rownames(aggdata) <- c('1', '2')
# Manipulando formato
aggdata <- melt(t(aggdata), id.vars = NULL)
colnames(aggdata) <- c('Instancia_Grupo', 'Algoritmo', 'f')
# Transformando variáveis categóricas em fatores
for (i in 1:2) aggdata[, i] <- as.factor(aggdata[, i])
model <- aov(formula = log(f)~Algoritmo+Instancia_Grupo, data = aggdata)
model
summary.lm(model)$r.squared
aggdata
model$coefficients
model$model
# A few initial definitions just to make sure all required packages are installed. Change as needed.
# NOTE: It may echo some weird messages to the PDF on the first compile (package installation messages). Run twice and the problem will (hopefully) go away.
if (!require(ggplot2, quietly = TRUE)){
install.packages("ggplot2")
}
if (!require(devtools, quietly = TRUE)){
install.packages("devtools")
}
if (!require(GGally, quietly = TRUE)){
install.packages("GGally")
}
if (!require(broom, quietly = TRUE)){
devtools::install_github("dgrtwo/broom")
}
if (!require(stats, quietly = TRUE)){
suppressMessages(install.packages("stats"))
}
if (!require(plotly, quietly = TRUE)){
suppressMessages(install.packages("plotly"))
}
if (!require(reshape2, quietly = TRUE)){
suppressMessages(install.packages("reshape2"))
}
if (!require(tidyr, quietly = TRUE)){
suppressMessages(install.packages("tidyr"))
}
if (!require(pracma, quietly = TRUE)){
suppressMessages(install.packages("pracma"))
}
if (!require(lsr, quietly = TRUE)){
suppressMessages(install.packages("lsr"))
}
if (!require(car, quietly = TRUE)){
suppressMessages(install.packages("car"))
}
if (!require(pwr, quietly = TRUE)){
suppressMessages(install.packages("pwr"))
}
if (!require(multcompView, quietly = TRUE)){
suppressMessages(install.packages("multcompView"))
}
if (!require(multcomp, quietly = TRUE)){
suppressMessages(install.packages("multcomp"))
}
if (!require(lmtest, quietly = TRUE)){
suppressMessages(install.packages("lmtest"))
}
if (!require(effectsize, quietly = TRUE)){
suppressMessages(install.packages("effectsize"))
}
if (!require(CAISEr, quietly = TRUE)){
suppressMessages(install.packages("CAISEr"))
}
# Statistical package
library(stats)
# Ggplot2 package
library(ggplot2)
# Plotly package
library(plotly)
# Reshape2 package
library(reshape2)
# GGally package
library(GGally)
# Tidyr package
library(tidyr)
# Pracma package
library(pracma)
# Lsr package
library(lsr)
# Car package
library(car)
# Pwr package
library(pwr)
# Tukey package
library(multcompView)
# Multiple comparisons
library(multcomp)
# Durbin Watson Test package
library(lmtest)
# Effect Size for ANOVA
library(effectsize)
# Comparison of algorithms with iterative sample size estimation
library(CAISEr)
# UFT-8 Encoding
options(Encoding="UTF-8")
rosenbrock <- function(X, Y){
f = (1-X)^2 + 100*(Y-X^2)^2
return(f)
}
x <- y <- seq(from = -5, to = 10, by = 1)
par(mar = c(2, 2, 2, 1))
persp(x = x, y = y, z = outer(x, y, rosenbrock),
zlab = 'f(x,y)',
theta = -120,
col = 'steelblue',
shade = 0.5)
out <- calc_instances(ncomparisons = 1,
d = 0.5,
power = 0.80,
sig.level = 0.05,
alternative.side = "one.sided",
power.target = "mean")
cat('Número de instâncias necessárias:', out$ninstances)
options(width = 90)
round(linspace(2, 150, out$ninstances), digits = 0)
# Leitura dos dados
data <- read.csv('CS4.csv', sep = ',', head = FALSE, skip = 1)
# Remove índices da primeira coluna
data <- data[2:length(data)]
# Separa qualidade das soluções do tempo de execução
ninstances <- ncol(data)/4
fobjs <- data[1:(2*ninstances)]
times <- data[(2*ninstances+1):ncol(data)]
# Separa qualidade das soluções dos dois algoritmos
algo1 <- fobjs[1:ninstances]
algo2 <- fobjs[(ninstances+1):(2*ninstances)]
# Renomeando as colunas
colnames(algo1) <- as.character(2:150)
colnames(algo2) <- as.character(2:150)
# Média de desempenho do algoritmo 1
muAlgo1 <- as.vector(colMeans(algo1))
# Média de desempenho do algoritmo 2
muAlgo2 <- as.vector(colMeans(algo2))
# Estruturando dados do algoritmo 1 para gráfico de linhas no ggplot2
label <- rep('1', ninstances)
variable <- 2:150
arr1 <- melt(muAlgo1, id.vars = NULL)
head <- cbind(variable, arr1, label)
# Estruturando dados do algoritmo 2 para gráfico de linhas no ggplot2
label <- rep('2', ninstances)
arr2 <- melt(muAlgo2, id.vars = NULL)
tail <- cbind(variable, arr2, label)
# União dos desempenhos dos dois algoritmos em todas as instâncias
merged <- rbind(head, tail)
# Lineplot
p <- ggplot(merged, aes(x = variable, y = value, color = label)) + geom_line()
p + labs(x = "Dimensão", y = "Fitness médio") +
guides(color=guide_legend(title="Algoritmo")) +
scale_color_manual(values = c("steelblue", "darkred"))
# Estruturando dados do algoritmo 1 para boxplots no ggplot2
label <- rep('1', (33 * ninstances))
arr1 <- melt(algo1, id.vars = NULL)
head <- cbind(arr1, label)
# Estruturando dados do algoritmo 2 para boxplots no ggplot2
label <- rep('2', (33 * ninstances))
arr2 <- melt(algo2, id.vars = NULL)
tail <- cbind(arr2, label)
# União dos desempenhos dos dois algoritmos nas dez primeiras instâncias
merged <- rbind(head(head, 33*10), head(tail, 33*10))
# Boxplot
p <- ggplot(data = merged, aes(x=variable, y=value)) + geom_boxplot(aes(fill=label))
p + labs(x = "Dimensão", y = "Fitness") +
scale_fill_manual(name = "Algoritmo", values = c("#56B4E9", "#CD5C5C"))
# União dos desempenhos dos dois algoritmos nas dez últimas instâncias
merged <- rbind(tail(head, 33*10), tail(tail, 33*10))
# Boxplot
p <- ggplot(data = merged, aes(x=variable, y=value)) + geom_boxplot(aes(fill=label))
p + labs(x = "Dimensão", y = "Fitness") +
scale_fill_manual(name = "Algoritmo", values = c("#56B4E9", "#CD5C5C"))
# Calcula relação entre potência e tamanho amostral
interval <- 2:150
power_values <- c()
for (i in interval) {
out <- calc_instances(ncomparisons = 1,
d = 0.5,
ninstances = i,
sig.level = 0.05,
alternative.side = "one.sided",
power.target = "mean")
power_values[i-1] <- out$power
}
df <- data.frame(x = interval, y = power_values)
ggplot(data = df, aes(x = x, y = y, group = 1)) +
xlab('Número de instâncias') +
ylab('Potência do teste') +
geom_line(linetype = 'dashed')+
geom_point()
out <- calc_instances(ncomparisons = 1,
d = 0.5,
ninstances = 149,
sig.level = 0.05,
alternative.side = "one.sided",
power.target = "mean")
cat('Potência alcançada:', out$power)
# Agregando desempenho médio dos algoritmos em todas as instâncias
aggdata <- data.frame(rbind(muAlgo1, muAlgo2))
# Renomeando colunas
colnames(aggdata) <- as.character(2:150)
# Renomeando linhas
rownames(aggdata) <- c('1', '2')
# Manipulando formato
aggdata <- melt(t(aggdata), id.vars = NULL)
colnames(aggdata) <- c('Instancia_Grupo', 'Algoritmo', 'f')
# Transformando variáveis categóricas em fatores
for (i in 1:2) aggdata[, i] <- as.factor(aggdata[, i])
model <- aov(formula = log(f)~Algoritmo+Instancia_Grupo, data = aggdata)
model
summary.lm(model)$r.squared
```{r}
dunnet_test <- glht(model, linfct = mcp(Algoritmo = "Dunnett"))
dunnet_CI <- confint(dunnet_test)
par(mar = c(5, 8, 4, 2), las = 1)
plot(duntestCI, xlab = "Mean difference (log scale)")
```
```{r}
dunnet_test <- glht(model, linfct = mcp(Algoritmo = "Dunnett"))
dunnet_CI <- confint(dunnet_test)
par(mar = c(5, 8, 4, 2), las = 1)
plot(dunnet_CI, xlab = "Mean difference (log scale)")
```
# Conclusões
```{r}
dunnet_test <- glht(model, linfct = mcp(Algoritmo = "Dunnett"))
dunnet_CI <- confint(dunnet_test)
par(mar = c(5, 8, 4, 2), las = 1)
plot(dunnet_CI, xlab = "Mean difference (log scale)")
```
```{r}
duntest <- glht(model, linfct = mcp(Algoritmo = "Dunnett"))
duntestCI <- confint(duntest)
par(mar = c(5, 8, 4, 2), las = 1)
plot(duntestCI, xlab = "Mean difference (log scale)")
```
duntestCI
```{r}
duntest <- glht(model, linfct = mcp(Algoritmo = "Dunnett"))
duntestCI <- confint(duntest)
par(mar = c(5, 8, 4, 2), las = 1)
plot(duntestCI, xlab = "Mean difference (log scale)")
```
duntest
```{r}
duntest <- glht(model, linfct = mcp(Algoritmo = "Dunnett"))
duntestCI <- confint(duntest)
par(mar = c(5, 8, 4, 2), las = 1)
plot(duntestCI, xlab = "Mean difference (log scale)")
```
duntest <- glht(model, linfct = mcp(Algoritmo = "Dunnett"))
library(multcomp)
```{r}
duntest <- glht(model, linfct = mcp(Algoritmo = "Dunnett"))
duntestCI <- confint(duntest)
par(mar = c(5, 8, 4, 2), las = 1)
plot(duntestCI, xlab = "Mean difference (log scale)")
```
duntest
setwd("~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project")
library(irace)
load(irace.Rdata)
load("~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/irace.Rdata")
iraceResults
iraceResults$allElites
iraceResults$state$eliteConfigurations
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
out$Fbest
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
out$Fbest
iraceResults$state$eliteConfigurations
load("~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/irace.Rdata")
iraceResults$state$eliteConfigurations
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
out$Fbest
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
out$Fbest
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
out$Fbest
recpars <- list(list(name = "recombination_blxAlphaBeta", alpha = 0.4, beta = 0.4), list(name = "recombination_blxAlphaBeta", alpha = 0.4, beta = 0.4))
recpars
recpars[1]
recpars[2]
length(recpars)
# Test dimensions (10, 50)
testdims <- c(10, 50)
# 28 functions (1 to 28)
allfuns <- 1:28
length(allfuns)
length(allfuns)*length(testdims)
length(allfuns)*length(testdims)*algos
length(allfuns)*length(testdims)*algos
load("~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/irace.Rdata")
iraceResults$state$eliteConfigurations
iraceResults$state$eliteConfigurations[0]
iraceResults$state$eliteConfigurations[1]
iraceResults$state$eliteConfigurations[1,]
iraceResults$state$eliteConfigurations[1,]$mutpars.name
iraceResults$state$eliteConfigurations[1,]$mutpars.f
iraceResults$state$eliteConfigurations[2,]$mutpars.name
iraceResults$state$eliteConfigurations[2,]$mutpars.f
iraceResults$state$eliteConfigurations[1,]$recpars.name
iraceResults$state$eliteConfigurations[2,]$mutpars.cr
iraceResults$state$eliteConfigurations[2,]$recpars.cr
iraceResults$state$eliteConfigurations
# Recombination parameters
recpars <- list(list(name = iraceResults$state$eliteConfigurations[1,]$recpars.name, cr = iraceResults$state$eliteConfigurations[1,]$recpars.cr),
list(name = iraceResults$state$eliteConfigurations[2,]$recpars.name, cr = iraceResults$state$eliteConfigurations[2,]$recpars.cr),
list(name = iraceResults$state$eliteConfigurations[3,]$recpars.name, cr = iraceResults$state$eliteConfigurations[3,]$recpars.cr))
# Number of ExpDE versions
algos <- length(recpars)
# Fitness (33x(3*28*2)) -> (33x168)
fs <- matrix(nrow = n_runs, ncol = length(dimensions))
algos
length(allfuns)*length(testdims)*algos
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
iraceResults$state$eliteConfigurations[1,]$recpars.cr
iraceResults$state$eliteConfigurations[1,]$recpars.cr+1
iraceResults$state$eliteConfigurations[1,]$recpars.cr
iraceResults$state$eliteConfigurations[1,]$recpars.name
class(iraceResults$state$eliteConfigurations[1,]$recpars.name)
recpars[1]
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
alg
alg
algos
algos
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
algo
alg
mutpars[algo]
mutpars[1]
mutpars[alg]
mutpars[1]
mutpars[2]
class(mutpars[2])
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
class(mutpars[2])$name
mutpars[2]$ma,e
mutpars[2]$name
mutpars[2]
mutpars[2]$name
mutpars[2]$f
unlist(mutpars[2])$name
unlist(mutpars[2])
unlist(mutpars[2])[1]
unlist(mutpars[2])[1,]
unlist(mutpars[2])[1]
unlist(mutpars[2])
class(unlist(mutpars[2]))
mutpars[2]$[1]
mutpars[2]$[1]$name
mutpars[2]$name
unlist(recpars)
mutpars[2]$recpars.f
iraceResults$state$eliteConfigurations[3,]$recpars.name
recpars
recpars[1]
recpars[2]
recpars[3]
recpars[3]$[[1]]$name
recpars$[[1]]$name
recpars$name
recpars
attributes(mutpars[alg])
attributes(mutpars[alg]$name)
attributes(mutpars[[alg]]$name)
attributes(mutpars[[alg]])
attributes(mutpars[[1]])
mutpars
attributes(mutpars[[1]])
attributes(mutpars)
attributes(mutpars[])
attributes(mutpars[2])
attributes(mutpars[[2]])
mutpars[[alg]]
mutpars[[alg]]$name
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
i
**
1*2*3
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
source('~/Dropbox/Mestrado/Disciplinas/Planejamento e Análise de Experimentos/Design-and-Analysis-of-Experiments/Final Project/run.R')
iraceResults
iraceResults$state$eliteConfigurations
# Number of runs
n_runs = 33
results <- iraceResults$testing$experiments
res.df <- data.frame(do.call(rbind, strsplit(rownames(results), "_")),
results,
stringsAsFactors = FALSE)[, -1]
colnames(res.df)  <- c("Problem", "Dimension", 1:(ncol(res.df)-2))
res.df$Problem <- sprintf("%02d", as.numeric(res.df$Problem))
res.df$Objectives <- ifelse(res.df$Problem %in% c("08", "09", "10"),
yes = "3 obj",
no  = "2 obj")
res.df$Dimension <- paste0("Dim = ", res.df$Dimension)
require(reshape2)
res.df <- reshape2::melt(res.df, value.name = "IGD")
names(res.df)[4] <- "Configuration"
suppressPackageStartupMessages(library(irace))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(smoof))
### Precondition results
results <- iraceResults$testing$experiments
res.df <- data.frame(do.call(rbind, strsplit(rownames(results), "_")),
results,
stringsAsFactors = FALSE)[, -1]
colnames(res.df)  <- c("Problem", "Dimension", 1:(ncol(res.df)-2))
res.df$Problem <- sprintf("%02d", as.numeric(res.df$Problem))
res.df$Objectives <- ifelse(res.df$Problem %in% c("08", "09", "10"),
yes = "3 obj",
no  = "2 obj")
res.df$Dimension <- paste0("Dim = ", res.df$Dimension)
require(reshape2)
res.df <- reshape2::melt(res.df, value.name = "IGD")
names(res.df)[4] <- "Configuration"
## Plot resulting IGD of best configurations returned, by problem and dimension
require(ggplot2)
ml2 <- ggplot2::theme(axis.title  = ggplot2::element_text(size = 18),
axis.text   = ggplot2::element_text(size = 10),
legend.text = ggplot2::element_text(size = 18))
mp <- ggplot2::ggplot(res.df, ggplot2::aes(x      = Problem,
y      = IGD,
colour = Configuration,
group  = Configuration))
mp +
ggplot2::geom_boxplot(ggplot2::aes(fill   = NULL,
colour = NULL,
group  = Problem),
alpha = 0.6,
lwd   = 0.1) +
ggplot2::geom_point() + ggplot2::geom_line() + ggplot2::facet_grid(.~Dimension) + ml2
```
results
